name: Deploy Site (pull + restart IIS + ensure Postgres)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: site-deploy-${{ github.ref }}
  cancel-in-progress: true

# ─────────── EDIT PER SERVER ──────────────────────────────────────────
env:
  SITE_PATH: 'C:\\inetpub\\wwwroot\\zetaslate'      # IIS site folder
# ──────────────────────────────────────────────────────────────────────

jobs:
  deploy:
    runs-on: [ self-hosted, windows, x64 ]
    defaults:
      run:
        shell: powershell

    steps:
    # 0 ── check-out repo
    - uses: actions/checkout@v4

    # 0½ ── derive host + export env (PowerShell-5 safe)
    - name: Load project config
      run: |
        $cfgPath = "${{ github.workspace }}\project-config.json"
        $cfg     = @{ }
        if (Test-Path $cfgPath) {
          $cfg = Get-Content -Raw $cfgPath | ConvertFrom-Json
        }

        $siteName = Split-Path -Leaf $Env:SITE_PATH
        $domain   = '.com'
        if ($cfg -ne $null -and $cfg.PSObject.Properties['websitedomain']) {
          if ($cfg.websitedomain) { $domain = $cfg.websitedomain }
        }

        $siteHost = "$siteName$domain"
        "WARMUP_URL=https://$siteHost/"                | Out-File $Env:GITHUB_ENV -Append
        "DJANGO_ALLOWED_HOSTS=$siteHost,www.$siteHost" | Out-File $Env:GITHUB_ENV -Append
        "SITE_NAME=$siteName"                          | Out-File $Env:GITHUB_ENV -Append

    # 1 ── configure Git for IIS working tree
    - name: Configure Git
      run: |
        git config --global --add safe.directory $Env:SITE_PATH
        $url = "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
        git -C $Env:SITE_PATH remote set-url origin $url

    - name: Set global Git identity
      run: |
        git config --global user.name  "${{ github.actor }} (GitHub Actions)"
        git config --global user.email "${{ github.actor }}@users.noreply.github.com"

    # 2 ── pull latest code
    - name: Pull site code
      run: |
        git -C $Env:SITE_PATH fetch --all --prune
        git -C $Env:SITE_PATH reset --hard origin/main

    # 3 ── Python & requirements
    - uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: pip
        cache-dependency-path: 'requirements.txt'

    - name: Install requirements
      run: |
        python -m pip install --upgrade pip
        python -m pip install -r "${{ github.workspace }}\requirements.txt"

    # 4 ── restart IIS
    - name: Restart IIS
      run: |
        iisreset /stop
        iisreset /start

    # 5 ── ensure PostgreSQL cluster / service
    - name: Ensure & (re)start PostgreSQL
      run: |
        $svc = Get-WmiObject Win32_Service | Where-Object { $_.Name -like 'postgresql*' } |
               Sort-Object Name -Descending | Select-Object -First 1
        if (-not $svc) { throw 'PostgreSQL service not found' }

        $cmd = $svc.PathName
        Write-Host  "Service name : $($svc.Name)"
        Write-Host  "Image path   : $cmd"

        # pg_ctl.exe (quoted OR unquoted)
        if ($cmd -match '"([^"]+\\pg_ctl\.exe)"') {
          $pgCtl = $Matches[1]
        } elseif ($cmd -match '([^\s"]+\\pg_ctl\.exe)') {
          $pgCtl = $Matches[1]
        } else { throw 'pg_ctl.exe not found in service command' }

        # data dir after -D
        if ($cmd -match '-D\s+"([^"]+)"') {
          $data = $Matches[1]
        } elseif ($cmd -match '-D\s+([^\s"]+)') {
          $data = $Matches[1]
        } else { throw '-D <data dir> not found in service command' }

        Write-Host "pg_ctl.exe    : $pgCtl"
        Write-Host "Data dir      : $data"

        if (-not (Test-Path $data)) {
          Write-Host 'Initialising PostgreSQL cluster …'
          & "$pgCtl" initdb -D "$data"
          & "$pgCtl" register -N $svc.Name -D "$data" -U 'NT AUTHORITY\NetworkService'
          Set-Service $svc.Name -StartupType Automatic
          Start-Service $svc.Name
        } else {
          Restart-Service $svc.Name -Force
        }

    # 5¾ ── create role & DB once (PowerShell-5 safe)
    - name: Ensure DB & role exist
      run: |
        $Env:PGPASSWORD = $Env:POSTGRES_PASSWORD
        echo "::add-mask::$Env:PGPASSWORD"

        # pick names (defaults to SITE_NAME)
        if ($Env:POSTGRES_DB)   { $db   = $Env:POSTGRES_DB }   else { $db   = $Env:SITE_NAME }
        if ($Env:POSTGRES_USER) { $user = $Env:POSTGRES_USER } else { $user = $Env:SITE_NAME }

        # super-user and locate psql.exe in same bin dir as pg_ctl
        $sup  = $Env:POSTGRES_SUPERUSER
        $svc  = Get-WmiObject Win32_Service | Where-Object { $_.Name -like 'postgresql*' } |
                Sort-Object Name -Descending | Select-Object -First 1
        if ($svc.PathName -match '"([^"]+\\)pg_ctl\.exe"' )   { $bin = $Matches[1] }
        elseif ($svc.PathName -match '([^\s"]+\\)pg_ctl\.exe'){ $bin = $Matches[1] }
        else { $bin = '' }

        $psql = $bin ? ($bin + 'psql.exe') : 'psql'
        if (-not (Test-Path $psql)) { $psql = 'psql' }

        # role
        $roleExists = & "$psql" -U $sup -tAc "SELECT 1 FROM pg_roles WHERE rolname='$user'" 2>$null
        if (-not $roleExists) {
          & "$psql" -U $sup -c "CREATE USER $user WITH PASSWORD '$Env:POSTGRES_PASSWORD';"
        }

        # database
        $dbExists = & "$psql" -U $sup -tAc "SELECT 1 FROM pg_database WHERE datname='$db'" 2>$null
        if (-not $dbExists) {
          & "$psql" -U $sup -c "CREATE DATABASE $db OWNER $user;"
        }

    # 6 ── Django migrations
    - name: Django migrate
      run: |
        cd $Env:SITE_PATH
        python manage.py migrate --noinput

    # 7 ── warm-up
    - name: Warm-up request
      run: |
        Invoke-WebRequest -Uri $Env:WARMUP_URL -UseBasicParsing -TimeoutSec 30
